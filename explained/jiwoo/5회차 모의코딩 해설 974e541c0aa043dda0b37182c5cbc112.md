# 5회차 모의코딩 해설.

## 출제 범위

- 이번 모의 코딩 문제 중 1번문제와 5번문제는 인하대 2020 경진대회에서 실버 1, 골드 1 문제를 가져와  출제하였습니다.

    [2020 인하대학교 프로그래밍 경진대회(IUPC)](https://www.acmicpc.net/category/detail/2381)

- 나머지 2,3,4 문제는 일반적인 solved.ac의 쿼리 검색 결과 중, 문제 분류를 다르게 하여 출제하였습니다.

## 05회차 - 유사 문제 문제집

유사 문제들을 모아서 그룹에 문제집을 만들었습니다. 더 도전해보고싶으신 분들은 도전해보시길 바랍니다.

[로그인](https://www.acmicpc.net/group/workbook/view/10051/30704)

# 1번 - Sort 마스터 배지훈의 후계자 (20551번)

[20551번: Sort 마스터 배지훈의 후계자](https://www.acmicpc.net/problem/20551)

## 방법 1 : Map으로 풀기.

단순히 있는지 없는지 체크하기 때문에, 간단하게 Map 자료구조를 활용하여 있는지 없는지 체크할 수 있습니다. 간단하니 넘어가겠습니다.

## 방법 2 : lower_bound로 풀기 (이분탐색으로 풀기)

c++ stl인 lower_bound는 정렬된 리스트를 기준으로 target값이거나, 없다면 그 다음으로 큰 값의 idx를 넘겨줍니다.

```cpp
scanf("%d %d", &N, &M);
for (i = 0; i < N; i++) scanf("%d", &in[i]);
sort(in, in + N);
while (M--) {
	int t;
	scanf("%d", &t);
	int p = lower_bound(in, in + N, t) - in;
	if (p == N || in[p] != t) printf("-1\n");
	else printf("%d\n", p);
}
```

따로 lower_bound가 없는 java 언어의 경우 이분탐색으로 간단히 lower_bound를 구현할 수 있습니다.

```java
private static int lowerBound(List<Integer> data, int target) {
    int begin = 0;
    int end = data.size();
    
    while(begin < end) {
    	int mid = (begin + end) / 2;
        
        if(data.get(mid) >= target) {
        	end = mid;
        }
        else {
        	begin = mid + 1;
        }
    }
    return end;
}
```

## 유사문제

[1920번: 수 찾기](https://www.acmicpc.net/problem/1920)

# 2번 - 도영이가 만든 맛있는 음식 (2961번)

[2961번: 도영이가 만든 맛있는 음식](https://www.acmicpc.net/problem/2961)

모두 부분집합 개념을 활용해서 풀었기 때문에 설명은 패스하겠습니다.

한가지 c++에서 다른 코드를 보여드리자면,

```cpp
void solve(int here,ll x,ll y){
	if(here==n){
		if(y!=0) ans=min(ans,llabs(x-y));
			return;
	}
	solve(here+1,x,y);
	solve(here+1,x*a[here].fs,y+a[here].sc);
}
```

loutput도 long long으로 나오는 llabs함수를 사용한것을 볼 수 있습니다. 물론 일반 abs로도 테케 통과 됩니다.

### 유사 문제

[1182번: 부분수열의 합](https://www.acmicpc.net/problem/1182)

# 3번 : 휴게소 세우기 (1477번)

[1477번: 휴게소 세우기](https://www.acmicpc.net/problem/1477)

## 방법 1 : Parametric Search (매개 변수 탐색)

### Parametric Search

파라메트릭 탐색 방법은 이분 탐색을 응용한 방식입니다.

어떻게 이분탐색을 응용했는지 알아보겠습니다.

예를들어서 function(in d) 가 있다고 가정합니다.

```cpp
int func(int d) {
	if ( some condition ) return 1;
	else return 0;
}
```

정의한 조건에 맞으면, function(int d)에서 return 으로 1, 아니면 0이 나오는 함수입니다.

d가 올 수 있는 범위가 1부터 100까지라고 하고, 그 범위에 해당하는 함수를 모두 돌린다고 가정하면..

[1, 0, 0, 0, 1 ,0 , 0.... ... ,0 ]

주어진 조건에 따라 이런식으로 결과가 나올것입니다. 

이 함수의 **결과값의 분포가 특별한 규칙을 가진다면** 어떨까요? 예를들어서...

- func(int d)가 return값이 0이면, d보다 작은 모든 수에서는 모두 0이라는 결과가 나오고
- func(int d)의 return값이 1이면, d보다 큰 모든 수에서는 모두 1이라는 결과가 나옵니다.

그런 특성을 가진 조건을 가진 함수라면 매번 아래와 같은 방식으로 분포되어 나올것입니다.

[0, 0, 0, 0, 0, 1, 1, 1, .... , 1]

이런 결과가 있으면, 이분탐색의 특징을 활용해 볼 수 있습니다.

![5%E1%84%92%E1%85%AC%E1%84%8E%E1%85%A1%20%E1%84%86%E1%85%A9%E1%84%8B%E1%85%B4%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B5%E1%86%BC%20%E1%84%92%E1%85%A2%E1%84%89%E1%85%A5%E1%86%AF%20974e541c0aa043dda0b37182c5cbc112/_2021-02-19__12.58.52.png](5%E1%84%92%E1%85%AC%E1%84%8E%E1%85%A1%20%E1%84%86%E1%85%A9%E1%84%8B%E1%85%B4%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B5%E1%86%BC%20%E1%84%92%E1%85%A2%E1%84%89%E1%85%A5%E1%86%AF%20974e541c0aa043dda0b37182c5cbc112/_2021-02-19__12.58.52.png)

[https://www.youtube.com/watch?v=F6lKjRDlOpk](https://www.youtube.com/watch?v=F6lKjRDlOpk)

예를들어서, 이분 탐색을 통해서 빠르게 0에서 1로 바뀌는 구간을 찾아볼 수 있습니다.

만약에 50번째의 결과가 0이 나왔다고 하면, 앞쪽은 모두 0이 나왔을것이기 때문에,

![5%E1%84%92%E1%85%AC%E1%84%8E%E1%85%A1%20%E1%84%86%E1%85%A9%E1%84%8B%E1%85%B4%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B5%E1%86%BC%20%E1%84%92%E1%85%A2%E1%84%89%E1%85%A5%E1%86%AF%20974e541c0aa043dda0b37182c5cbc112/_2021-02-19__5.20.16.png](5%E1%84%92%E1%85%AC%E1%84%8E%E1%85%A1%20%E1%84%86%E1%85%A9%E1%84%8B%E1%85%B4%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B5%E1%86%BC%20%E1%84%92%E1%85%A2%E1%84%89%E1%85%A5%E1%86%AF%20974e541c0aa043dda0b37182c5cbc112/_2021-02-19__5.20.16.png)

최초로 1이 나온 lower_bound은 반드시 51~100 사이에 있을것입니다.

![5%E1%84%92%E1%85%AC%E1%84%8E%E1%85%A1%20%E1%84%86%E1%85%A9%E1%84%8B%E1%85%B4%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B5%E1%86%BC%20%E1%84%92%E1%85%A2%E1%84%89%E1%85%A5%E1%86%AF%20974e541c0aa043dda0b37182c5cbc112/_2021-02-19__5.20.23.png](5%E1%84%92%E1%85%AC%E1%84%8E%E1%85%A1%20%E1%84%86%E1%85%A9%E1%84%8B%E1%85%B4%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B5%E1%86%BC%20%E1%84%92%E1%85%A2%E1%84%89%E1%85%A5%E1%86%AF%20974e541c0aa043dda0b37182c5cbc112/_2021-02-19__5.20.23.png)

이런 특징을 가지려면 조건식이 특별한 규칙을 낼 수 있는 조건식이어야 합니다.

예를들면 아래와 같습니다.

![5%E1%84%92%E1%85%AC%E1%84%8E%E1%85%A1%20%E1%84%86%E1%85%A9%E1%84%8B%E1%85%B4%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B5%E1%86%BC%20%E1%84%92%E1%85%A2%E1%84%89%E1%85%A5%E1%86%AF%20974e541c0aa043dda0b37182c5cbc112/_2021-02-19__5.21.17.png](5%E1%84%92%E1%85%AC%E1%84%8E%E1%85%A1%20%E1%84%86%E1%85%A9%E1%84%8B%E1%85%B4%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B5%E1%86%BC%20%E1%84%92%E1%85%A2%E1%84%89%E1%85%A5%E1%86%AF%20974e541c0aa043dda0b37182c5cbc112/_2021-02-19__5.21.17.png)

이 특성을 활용해서 문제를 풀어보자면...

- "func(int d)에서 return값이 1/0이 되는 최소값/최대값을 구하라" 라는 문제는,
- "어떤 d에서 func(int d)의 값이 1인가?" 라는 결정문제로 만들고 ⇒ 범위에 맞는 모든 d값을 결정 한 값들을 모아서 ⇒ 최소값 (혹은 최대값을) 찾는 방향으로 쉽게 생각의 전환을 해서 문제를 접근할 수 있습니다.

### 휴게소 세우기를 Parametric Search 를 이용해 풀어보기.

> 휴게소를 m개를 추가로 지었을 때, 각 휴게소 사이의 거리의 최대값을 최소화 하라.
답 : 어떤 자연수.

는 아래의 의미로 다시 생각해볼 수 있습니다.

> 휴게소 m개를 추가로 지었을 때, 각 휴게소 사이의 거리의 최대값이 d 이하가 되게 만들 수 있을까?
답 : Yes / No

이런 결정 문제로 변환이 가능합니다.

이 조건은 한번 Yes가 나오면 (return 1) 그 다음부터는 계속 Yes가 나올 수 밖에 없으므로  Parametric Search를 사용하기에 적합합니다.

이 함수를 가지고 가장 처음으로 1이 되는 d의 위치를 이분탐색하면서 최소값을 찾는게 목적입니다.

함수정의

- func(int d) : 간격이 d 이하기 위해서 필요한 추가 휴게소의 개수가 m 이하인가?
- d이하를 구하는 로직이 더 간단하기 때문에, d 이하로 만들었을 때 휴게소의 개수를 구하는 문제로 순서를 바꿔서 함수를 구현하였습니다.

```cpp
bool func(int d) {
	for (int i = 1; i < n ; i ++) {
		if (a[i] - a[i-1] <= d) continue;
		cnt += (a[i]-a[i-1]-1)/d;
	}
  return cnt <= m;
}
```

차이를 d로 나누면, 결과적으로 몇개의 휴게소가 필요한지 체크합니다.

그리고, 그 휴게소가 총 몇개 필요한지 체크합니다.

최초로 func(d)가 1이 나오는 부분을 찾으면 됩니다.

```cpp
int start = 1; // 항상 결과가 0입니다. (불변조건)
int end = 1001; // 항상 결과가 1입니다. (불변조건)
// [ 0 , ? ? ? ? ? ? ? ? ? ?... 1 ]

while(st < en){
  int mid = (st+en)/2;
  if(func(mid)) en = mid; 
  else st = mid+1;
}
```

## 방법 2: 우선순위 큐를 사용하는 방법 (Greedy)

1. 우선순위 큐에 각 휴게소의 차이를 저장해둡니다.
2. 휴게소의 차이를 우선순위 큐에 넣어두고, 차이를 반으로 나눈 뒤에 다시 우선순위 큐에 넣습니다.

하지만, ⚠️ 우선순위 큐를 위와같이 활용했으면 틀립니다.

예를들어서, 아래와 같은 케이스를 살펴보겠습니다.

```cpp
// M = 2 휴게소 2개를 더 세울것.

[100, 500, 600]

// PQ에는 각 구간의 차이를 넣어둘것.
PQ = [400, 100]

// 최대 차이를 한개 뽑아서 나눈다.
int top = pq.top();
pq.pop();
pq.push(pq.top() / 2);
pq.push(pq.top() / 2);

// 휴게소를 1개 세운 경우
PQ = [200, 200, 100]

// 최대 차이를 한개 뽑아서 두개로 나눈다.
int top = pq.top();
pq.pop();
pq.push(pq.top() / 2);
pq.push(pq.top() / 2);

// 휴게소를 2개 세운 경우
PQ = [200, 100, 100, 100]

```

위와 같은 케이스에서는 답으로 200을 뽑게 되겠지만,

```cpp
BEFORE : [100, 500, 600]
AFTER : [100  234(+M1)  367(+M2)  500  600]
```

위의 예제에서 2개의 휴게소를 세웠을 때 올바른 해는 133이 됩니다. (233 - 100) = 133

단순한 PQ를 활용한 풀이가 틀린 이유는, 문제에서 요구하는 답변이 최대 차이를 최대한 최소로 만드는게 목적이 아니라, **휴게소를 짓고 난 후에 휴게소가 없는 구간의 최대값의 최소값으로 만드는게 목표이기 때문입니다.**

그래서 PQ를 사용하기 위해서는,

1. 단순히 최대 차이를 나누기 위해 PQ사용하지 말것. (단순히 구간길이의 최소를 만드는게 아니라, 각 구간별로 나누어진 영역이 최소가 되도록 하게 만드는것이 목적)
2. 뿐만 아니라 결과적으로, PQ를 활용해 정확한 해를 구할 수 있는지 체크할것.

### 탐욕법

PQ로 풀기 위해서는 **탐욕적인 아이디어를** 생각해 볼 수 있습니다.

매번 PQ에서 상단에 있는 값들은, 각 구간에서 나누어 가진 값들의 "단위" 중 최대의 값이라고 생각해 봅시다.

예를 들어서, 위의 예제에서는 100~500사이에서 133을 단위 기준으로 최종적으로 3등분 해서 나누어져 있고, 500~600에서 원래 있던대로 100을 기준으로 나누어져있으니... 

최종 PQ에는 = [133, 100] 이런식으로 들어가 있겠습니다.

그럼 탐욕법을 활용하여 PQ 활용 로직을 세워보자면,

1. 세워야 하는 휴게소의 수에 맞춰 m번 루프를 돌면서,
2. PQ상단에 있는 최대 구간 단위 길이를 뽑아 매번 적절하게 업데이트를 해주면, 
3. 결과적으로 최종해를 구할 수 있습니다.

그렇다면, 파라메트릭 서치처럼 전부를 순회하지않아도, PQ상단에 있는 최대 구간 단위 길이만 탐욕적으로 처리해도 정확한 해를 구할 수 있는 이유는 무엇일까요?

위의 파라메트릭 서치에서도 유추해볼 수 있듯이, func(d)이 처음에 모두 0이다가 1로 바뀌는 순간이 오는 빠르기는, 절대적으로 각 구간길이가 얼마나 기냐에 달려 있습니다. 긴 구간길이들이 많을수록, func(d)의 배열이 0이었다가 1로 나오는 순간이 더 느려집니다.

따라서 PQ에서는 이런 긴 구간 길이들을 우선적으로 처리해줍니다. 

이 행위를 굳이 파라메트릭 서치의 맥락에서 비유해보자면, 긴 구간들을 보고, 그 구간에 맞춰서 d값을 정해놓고 의도적으로 1을 빠르게 값을 구하는 행위와 비슷하다고도 볼 수 있을것 같습니다.

PQ에 넣는 로직.

```cpp
// 현재 가장 차이가 큰 길이를 뽑습니다. 
auto top = pq.top();
// 원래 최초의 차이를 복구합니다.
double original = top.first * top.second; 
int fragCnt = top.second + 1;
pq.pop();
// 최초 차이를 재등분 해서 PQ에 넣어줍니다.
pq.push({ original / fragCnt, fragCnt});
```

전체소스코드:

```cpp
int n, m, l;
cin >> n >> m >> l;
vector<int> arr = vector<int>(n+2);

for (int i = 1 ; i <= n ; i++) {
    cin >> arr[i];
}
arr[0] = 0;
arr[n+1] = l;

sort(arr.begin(), arr.end());

priority_queue<pair<double,int>> pq;
for (int i = 1 ; i <= n+1 ; i++) {
    pq.push({arr[i] - arr[i-1], 1});
}

while(m--) {
    auto top = pq.top();
    double original = top.first * top.second;
    int fragCnt = top.second + 1;
    pq.pop();
    pq.push({ original / fragCnt, fragCnt});
}

double dist = pq.top().first;
cout << ceil(dist) << endl
```

## 유사문제

[1300번: K번째 수](https://www.acmicpc.net/problem/1300)

[2110번: 공유기 설치](https://www.acmicpc.net/problem/2110)

[17976번: Thread Knots](https://www.acmicpc.net/problem/17976)

[추가강의소스](https://www.notion.so/2fd516f181d54bb6acda0d60f5bd8ed7)

# 4번 - 앱 (7579번)

[7579번: 앱](https://www.acmicpc.net/problem/7579)

0-1 Knapsack 문제는 워낙 유명하기 때문에 여기서 따로 설명하지 않습니다.

## 방법 1 : 2차원 dp로 풀기

Knapsack 변형 문제에서 중요한 부분은, 문제 그대로 풀기 보다는, 바로 풀이에 유리한 변수를 선택하여 답을 유도하는게 좋습니다.

예를들어서, 문제에서는 N제한은 100개, M제한은 10,000,000, 총 C제한은 100*100 이므로, 풀이를 짤 때 N과 M이 아닌 N과 C를 활용하여 올바른 해를 구할 수 있도록 유도해야합니다. 

DP를 풀기 위해서 

- 정의 : dp(i,cost) = 1부터 i번째 까지의 앱을 선택했을 때, cost 를 활용하여 최대로 제거할 수 있는 바이트의 값.
- 점화식 : dp(i, cost) = max(dp(i-1, cost), dp(i-1, cost - c[i]) + m[i]);
- 최종 답 : dp(n, j) 에서 최초로 주어진 m을 넘는 j 값.

```cpp

int n, m;
cin >> n >> m;

for (int i = 1; i <= n; i++) {
    cin >> memory[i];
}
for (int j = 1 ; j <= n ; j++) {
    cin >> cost[j];
}   

for (int i = 1; i <= n ; i++) {
    for (int j = 0 ; j < 10001; j++) {
        if ( cost[i] <= j) {
            dp[i][j] = max(dp[i-1][j], dp[i-1][j-cost[i]] + memory[i]);
        } else {
            dp[i][j] = dp[i-1][j];
        }
    }
}

for (int j = 0 ; j < 10001; j++) {
    if (dp[n][j] >= m) { 
        cout << j << endl;
        break;
    }
}
```

## 방법 2 : 2차원 배열 → 1차원 배열로 변경해서 풀기.

점화식을 보면 

- dp(i, cost) = max(dp(i-1, cost), dp(i-1, cost - c[i]) + m[i]);

모두 단순하게 i-1만  참조하고 있으므로, i를 쓰지 않더라도 묵시적으로 i-1 를 의미하고 있다는것을 압니다.

따라서, (i,j)를 담는 2차원 배열을 사용하지 않고 (j) 하나만 담는 1차원 배열로도 줄일 수 있습니다. 

시간복잡도와 점화식의 의미는 같고, 값을 제대로 할당하기 위해 dp 배열을 채우는 순서만 달라집니다.

```cpp
int n, m;
cin >> n >> m;

for (int i = 1; i <= n; i++) {
    cin >> memory[i];
}
for (int j = 1 ; j <= n ; j++) {
    cin >> cost[j];
}   

for (int i = 1; i <= n ; i++) {
    for (int j = 10000 ; j >= 0; j--) { // 거꾸로 채운다.
        if (j-cost[i] >= 0)
          dp[j] = max(dp[j], dp[j-cost[i]] + memory[i]);
    }
}

for (int j = 0 ; j < 10001; j++) {
    if (dp[j] >= m) { 
        cout << j << endl;
        break;
    }
}
```

## 유사문제

[12865번: 평범한 배낭](https://www.acmicpc.net/problem/12865)

[2629번: 양팔저울](https://www.acmicpc.net/problem/2629)

# 5번 - 폭탄 던지는 태영이 (25043번)

[20543번: 폭탄 던지는 태영이](https://www.acmicpc.net/problem/20543)

아래 블로그에 설명이 들어있습니다.

혹시 블로그의 이해가 어려우실 분들을 위해, 블로그를 이해하기 위해 필요한 지식들을 정리하였습니다.

[[C++] 백준 20543 폭탄 던지는 태영이](https://countrysides.tistory.com/54)

문제에서 M=3 이라고 주어졌다고 가정해봅시다.

input으로 주어진 아무 3*3 을 가져옵니다.

여기서 첫 3*3을 가져와봅니다.

![5%E1%84%92%E1%85%AC%E1%84%8E%E1%85%A1%20%E1%84%86%E1%85%A9%E1%84%8B%E1%85%B4%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B5%E1%86%BC%20%E1%84%92%E1%85%A2%E1%84%89%E1%85%A5%E1%86%AF%20974e541c0aa043dda0b37182c5cbc112/_2021-02-19__3.21.22.png](5%E1%84%92%E1%85%AC%E1%84%8E%E1%85%A1%20%E1%84%86%E1%85%A9%E1%84%8B%E1%85%B4%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B5%E1%86%BC%20%E1%84%92%E1%85%A2%E1%84%89%E1%85%A5%E1%86%AF%20974e541c0aa043dda0b37182c5cbc112/_2021-02-19__3.21.22.png)

여기서 3*3의 가운데인 -2는 이 3*3에 폭탄이 2개 있음을 암시합니다.

![5%E1%84%92%E1%85%AC%E1%84%8E%E1%85%A1%20%E1%84%86%E1%85%A9%E1%84%8B%E1%85%B4%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B5%E1%86%BC%20%E1%84%92%E1%85%A2%E1%84%89%E1%85%A5%E1%86%AF%20974e541c0aa043dda0b37182c5cbc112/_2021-02-19__3.21.32.png](5%E1%84%92%E1%85%AC%E1%84%8E%E1%85%A1%20%E1%84%86%E1%85%A9%E1%84%8B%E1%85%B4%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B5%E1%86%BC%20%E1%84%92%E1%85%A2%E1%84%89%E1%85%A5%E1%86%AF%20974e541c0aa043dda0b37182c5cbc112/_2021-02-19__3.21.32.png)

![5%E1%84%92%E1%85%AC%E1%84%8E%E1%85%A1%20%E1%84%86%E1%85%A9%E1%84%8B%E1%85%B4%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B5%E1%86%BC%20%E1%84%92%E1%85%A2%E1%84%89%E1%85%A5%E1%86%AF%20974e541c0aa043dda0b37182c5cbc112/Untitled.png](5%E1%84%92%E1%85%AC%E1%84%8E%E1%85%A1%20%E1%84%86%E1%85%A9%E1%84%8B%E1%85%B4%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B5%E1%86%BC%20%E1%84%92%E1%85%A2%E1%84%89%E1%85%A5%E1%86%AF%20974e541c0aa043dda0b37182c5cbc112/Untitled.png)

왜냐하면, 원래 배치되어있던 폭탄이 아래의 그림과 같다고 가정해봅시다.

그럼 저 폭탄들이 폭파하면서 3*3의 모두 가운데 지점에 영향을 주기 때문에 가운데는 -3이라는 값이 나옵니다.

즉, 저 영역에 폭탄이 3개가 들어가 있다는 의미입니다.

![5%E1%84%92%E1%85%AC%E1%84%8E%E1%85%A1%20%E1%84%86%E1%85%A9%E1%84%8B%E1%85%B4%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B5%E1%86%BC%20%E1%84%92%E1%85%A2%E1%84%89%E1%85%A5%E1%86%AF%20974e541c0aa043dda0b37182c5cbc112/Untitled%201.png](5%E1%84%92%E1%85%AC%E1%84%8E%E1%85%A1%20%E1%84%86%E1%85%A9%E1%84%8B%E1%85%B4%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B5%E1%86%BC%20%E1%84%92%E1%85%A2%E1%84%89%E1%85%A5%E1%86%AF%20974e541c0aa043dda0b37182c5cbc112/Untitled%201.png)

![5%E1%84%92%E1%85%AC%E1%84%8E%E1%85%A1%20%E1%84%86%E1%85%A9%E1%84%8B%E1%85%B4%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B5%E1%86%BC%20%E1%84%92%E1%85%A2%E1%84%89%E1%85%A5%E1%86%AF%20974e541c0aa043dda0b37182c5cbc112/Untitled%202.png](5%E1%84%92%E1%85%AC%E1%84%8E%E1%85%A1%20%E1%84%86%E1%85%A9%E1%84%8B%E1%85%B4%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B5%E1%86%BC%20%E1%84%92%E1%85%A2%E1%84%89%E1%85%A5%E1%86%AF%20974e541c0aa043dda0b37182c5cbc112/Untitled%202.png)

이 특징과 2차원 구간 부분합 특징을 이용하여 이 문제의 답을 구해볼 수 있습니다.

## 구간 부분합

### 1차원 부분합.

An = [1, 2, 3, 4, 5]라는 수열이 있을때,

Sn = [1, 3, 6, 10, 15] // A1부터 An항까지의 합. (예: S3 이면 A1항부터 A3항까지의 합)을 따로 기록해놓습니다.

그리고, An 부분수열의 구간 부분합을 구하고 싶을 때, Sn을 사용할 수 있습니다.

예를들어, An의 2번부터 4번까지의 합을 구하고싶으면, Sn[4] - Sn[1] 을 통해 O(1) 시간에 부분합을 구할 수 있습니다.

- S[4] = A1 + A2 + A3 + A4
- S[1] = A1S[4] - S[1] = A2 + A3 + A4

2차원 배열에서도 같은 원리로 부분합을 구할 수 있습니다.

### 2차원 부분합

### 2차원 배열에서 **Sn배열을 만들어 나갈 때,**

![5%E1%84%92%E1%85%AC%E1%84%8E%E1%85%A1%20%E1%84%86%E1%85%A9%E1%84%8B%E1%85%B4%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B5%E1%86%BC%20%E1%84%92%E1%85%A2%E1%84%89%E1%85%A5%E1%86%AF%20974e541c0aa043dda0b37182c5cbc112/Untitled%203.png](5%E1%84%92%E1%85%AC%E1%84%8E%E1%85%A1%20%E1%84%86%E1%85%A9%E1%84%8B%E1%85%B4%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B5%E1%86%BC%20%E1%84%92%E1%85%A2%E1%84%89%E1%85%A5%E1%86%AF%20974e541c0aa043dda0b37182c5cbc112/Untitled%203.png)

Sum[i][j] : (0,0) 부터 (i,j) 까지의 합.

```cpp
for (int i = 1 ; i <= n ; i ++) {
    for (int j = 1 ; j <= n; j++) {
        sum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + arr[i][j];
    }
}
```

### 2차원 배열에서 **Sum 배열을 활용해 구간합을 구할 때,**

![5%E1%84%92%E1%85%AC%E1%84%8E%E1%85%A1%20%E1%84%86%E1%85%A9%E1%84%8B%E1%85%B4%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B5%E1%86%BC%20%E1%84%92%E1%85%A2%E1%84%89%E1%85%A5%E1%86%AF%20974e541c0aa043dda0b37182c5cbc112/Untitled%204.png](5%E1%84%92%E1%85%AC%E1%84%8E%E1%85%A1%20%E1%84%86%E1%85%A9%E1%84%8B%E1%85%B4%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B5%E1%86%BC%20%E1%84%92%E1%85%A2%E1%84%89%E1%85%A5%E1%86%AF%20974e541c0aa043dda0b37182c5cbc112/Untitled%204.png)

```cpp
public static int getSum(int x1, int y1, int x2, int y2) {
    return sum[x2][y2] - sum[x1-1][y2] - sum[x2][y1-1] + sum[x1-1][y1-1];
}
```

이를 통해 결과적으로 **검은색 부분만의** 구간 부분합을 빠르게 구할 수 있습니다.

## 부분합 활용하기.

위 2차원 부분합의 특성과 문제의 특징을 활용하여 문제를 풀어보겠습니다.

아까 말했듯이, 이 문제에서 sum[i][j] (= input[i][j]) 는 3*3 주변의 폭탄개수의 총합이 됩니다.

따라서 이 정보를 부분 구간합의 sum[i][j]처럼 해석해볼 수 있습니다.

![5%E1%84%92%E1%85%AC%E1%84%8E%E1%85%A1%20%E1%84%86%E1%85%A9%E1%84%8B%E1%85%B4%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B5%E1%86%BC%20%E1%84%92%E1%85%A2%E1%84%89%E1%85%A5%E1%86%AF%20974e541c0aa043dda0b37182c5cbc112/Untitled%205.png](5%E1%84%92%E1%85%AC%E1%84%8E%E1%85%A1%20%E1%84%86%E1%85%A9%E1%84%8B%E1%85%B4%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B5%E1%86%BC%20%E1%84%92%E1%85%A2%E1%84%89%E1%85%A5%E1%86%AF%20974e541c0aa043dda0b37182c5cbc112/Untitled%205.png)

이를 구간 부분합의 공식을 생각하며 적용해보겠습니다.

아래는 구간합을 구할 때 사용했던 공식입니다.

![5%E1%84%92%E1%85%AC%E1%84%8E%E1%85%A1%20%E1%84%86%E1%85%A9%E1%84%8B%E1%85%B4%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B5%E1%86%BC%20%E1%84%92%E1%85%A2%E1%84%89%E1%85%A5%E1%86%AF%20974e541c0aa043dda0b37182c5cbc112/Untitled%206.png](5%E1%84%92%E1%85%AC%E1%84%8E%E1%85%A1%20%E1%84%86%E1%85%A9%E1%84%8B%E1%85%B4%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B5%E1%86%BC%20%E1%84%92%E1%85%A2%E1%84%89%E1%85%A5%E1%86%AF%20974e541c0aa043dda0b37182c5cbc112/Untitled%206.png)

주황색 점 부분의 폭탄 개수를 구하기 위해서는 위와 같은 공식을 이끌어 낼 수 있습니다.

![5%E1%84%92%E1%85%AC%E1%84%8E%E1%85%A1%20%E1%84%86%E1%85%A9%E1%84%8B%E1%85%B4%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B5%E1%86%BC%20%E1%84%92%E1%85%A2%E1%84%89%E1%85%A5%E1%86%AF%20974e541c0aa043dda0b37182c5cbc112/Untitled%207.png](5%E1%84%92%E1%85%AC%E1%84%8E%E1%85%A1%20%E1%84%86%E1%85%A9%E1%84%8B%E1%85%B4%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B5%E1%86%BC%20%E1%84%92%E1%85%A2%E1%84%89%E1%85%A5%E1%86%AF%20974e541c0aa043dda0b37182c5cbc112/Untitled%207.png)

다만 2차원 부분합에서 Sum[i][j] = (0,0) 부터 (i,j) 까지의 합 이었다면,

이 경우는 항상 3*3으로 크기가 고정되기 때문에, 

**쓸데없이 더 빼지거나, 덜 더해지는 경우는 보정해줘야합니다.**

어디를 더 더해주고, 더 뺴줘야 하는지 하는지 그림으로 살펴보겠습니다.

보라색영역은 아래와 같이 커버됩니다.

![5%E1%84%92%E1%85%AC%E1%84%8E%E1%85%A1%20%E1%84%86%E1%85%A9%E1%84%8B%E1%85%B4%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B5%E1%86%BC%20%E1%84%92%E1%85%A2%E1%84%89%E1%85%A5%E1%86%AF%20974e541c0aa043dda0b37182c5cbc112/Untitled%208.png](5%E1%84%92%E1%85%AC%E1%84%8E%E1%85%A1%20%E1%84%86%E1%85%A9%E1%84%8B%E1%85%B4%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B5%E1%86%BC%20%E1%84%92%E1%85%A2%E1%84%89%E1%85%A5%E1%86%AF%20974e541c0aa043dda0b37182c5cbc112/Untitled%208.png)

초록색영역입니다.

![5%E1%84%92%E1%85%AC%E1%84%8E%E1%85%A1%20%E1%84%86%E1%85%A9%E1%84%8B%E1%85%B4%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B5%E1%86%BC%20%E1%84%92%E1%85%A2%E1%84%89%E1%85%A5%E1%86%AF%20974e541c0aa043dda0b37182c5cbc112/Untitled%209.png](5%E1%84%92%E1%85%AC%E1%84%8E%E1%85%A1%20%E1%84%86%E1%85%A9%E1%84%8B%E1%85%B4%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B5%E1%86%BC%20%E1%84%92%E1%85%A2%E1%84%89%E1%85%A5%E1%86%AF%20974e541c0aa043dda0b37182c5cbc112/Untitled%209.png)

빨간색영역입니다.

![5%E1%84%92%E1%85%AC%E1%84%8E%E1%85%A1%20%E1%84%86%E1%85%A9%E1%84%8B%E1%85%B4%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B5%E1%86%BC%20%E1%84%92%E1%85%A2%E1%84%89%E1%85%A5%E1%86%AF%20974e541c0aa043dda0b37182c5cbc112/Untitled%2010.png](5%E1%84%92%E1%85%AC%E1%84%8E%E1%85%A1%20%E1%84%86%E1%85%A9%E1%84%8B%E1%85%B4%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B5%E1%86%BC%20%E1%84%92%E1%85%A2%E1%84%89%E1%85%A5%E1%86%AF%20974e541c0aa043dda0b37182c5cbc112/Untitled%2010.png)

마지막으로 노란색 영역입니다.

![5%E1%84%92%E1%85%AC%E1%84%8E%E1%85%A1%20%E1%84%86%E1%85%A9%E1%84%8B%E1%85%B4%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B5%E1%86%BC%20%E1%84%92%E1%85%A2%E1%84%89%E1%85%A5%E1%86%AF%20974e541c0aa043dda0b37182c5cbc112/Untitled%2011.png](5%E1%84%92%E1%85%AC%E1%84%8E%E1%85%A1%20%E1%84%86%E1%85%A9%E1%84%8B%E1%85%B4%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B5%E1%86%BC%20%E1%84%92%E1%85%A2%E1%84%89%E1%85%A5%E1%86%AF%20974e541c0aa043dda0b37182c5cbc112/Untitled%2011.png)

그럼 색깔이 겹쳐지지 않는 부분이 있습니다.

아래 주황색 체크 부분과, 파란색 체크 부분입니다.

![5%E1%84%92%E1%85%AC%E1%84%8E%E1%85%A1%20%E1%84%86%E1%85%A9%E1%84%8B%E1%85%B4%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B5%E1%86%BC%20%E1%84%92%E1%85%A2%E1%84%89%E1%85%A5%E1%86%AF%20974e541c0aa043dda0b37182c5cbc112/Untitled%2012.png](5%E1%84%92%E1%85%AC%E1%84%8E%E1%85%A1%20%E1%84%86%E1%85%A9%E1%84%8B%E1%85%B4%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B5%E1%86%BC%20%E1%84%92%E1%85%A2%E1%84%89%E1%85%A5%E1%86%AF%20974e541c0aa043dda0b37182c5cbc112/Untitled%2012.png)

주황색 체크 부분은 보라색이 마지막에 더해지면서 쓸데없이 추가된 부분.

파란색 체크 부분은 빨간색과 초록색이 빼지면서 쓸데없이 더 빠진 부분입니다.

따라서 이부분에 대해서 보충을 해줘야 합니다.

마지막으로 이 과정을 모두 일반화 하여 식으로 표현하면 이렇습니다.

![5%E1%84%92%E1%85%AC%E1%84%8E%E1%85%A1%20%E1%84%86%E1%85%A9%E1%84%8B%E1%85%B4%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B5%E1%86%BC%20%E1%84%92%E1%85%A2%E1%84%89%E1%85%A5%E1%86%AF%20974e541c0aa043dda0b37182c5cbc112/Untitled%2013.png](5%E1%84%92%E1%85%AC%E1%84%8E%E1%85%A1%20%E1%84%86%E1%85%A9%E1%84%8B%E1%85%B4%E1%84%8F%E1%85%A9%E1%84%83%E1%85%B5%E1%86%BC%20%E1%84%92%E1%85%A2%E1%84%89%E1%85%A5%E1%86%AF%20974e541c0aa043dda0b37182c5cbc112/Untitled%2013.png)

위 내용을 참고하시고, 아래 블로그의 내용을 보시면 훨씬 더 이해가 쉬울것입니다.

[[C++] 백준 20543 폭탄 던지는 태영이](https://countrysides.tistory.com/54)

## 유사문제

부분 구간합을 활용해볼 수 있는 간단한 문제들입니다.

[11660번: 구간 합 구하기 5](https://www.acmicpc.net/problem/11660)

[11659번: 구간 합 구하기 4](https://www.acmicpc.net/problem/11659)